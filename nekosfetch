#!/usr/bin/env node

const program = require('commander')
const fetch = require('node-fetch')

const validate = range => {
  if (range.some(r => r === undefined)) { return false }
  if (range[0] <= 0) { return false }
  if (range[0] >= range[1]) { return false }
  return true
}

const error = reason => {
  // match error msgs of commander
  console.error(`\n  error: ${reason}\n`)
  process.exit(1)
}

const pad = (padding, string, paddingLeft) => {
  if (string === undefined) { return padding }
  if (paddingLeft) { return (padding + string).slice(-padding.length) }
  return (string + padding).substring(0, padding.length)
}

function action (range) {
  if (range instanceof program.Command) {
    return error('no range given!')
  }

  range = range.split('..').map(Number) || []
  if (!validate(range)) {
    return error('invalid range!')
  }

  // These should make it easier to tweak for other sources
  const extNames = ['png', 'jpg', 'jpeg']
  const urlTemplate = 'https://cdn.nekos.life/neko/neko_%id%.%ext%'
  const idPadding = '000'

  const run = async (i, j) => {
    // Initiate vars for current iteration
    const id = pad(idPadding, i.toString(), true)
    const ext = extNames[j]

    // Run current iteration
    this.verbose && process.stdout.write(`run task: ${id}-${ext} ... `)

    const url = urlTemplate
      .replace(/%id%/g, id)
      .replace(/%ext%/g, ext)

    let found = null
    await fetch(url)
      .then(res => {
        if (res.status !== 200) {
          return this.verbose && process.stdout.write(String(res.status))
        }
        this.verbose && process.stdout.write('FOUND')
        found = true
      })
      .catch(error => {
        this.verbose && process.stdout.write(error.toString())
      })

    this.verbose && process.stdout.write('\n')
    if (found) { console.log(url) }

    // Continue to next iteration
    if (!found && j < extNames.length - 1) { return run(i, j + 1) }
    if (i < range[1]) { return run(i + 1, 0) }
    return true
  }

  run(range[0], 0)
    .then(() => {
      process.exit(0)
    })
    .catch(error => {
      console.error(error)
      process.exit(1)
    })
}

program
  .version('1.0.0')
  .usage('[options] <range>')
  .option('-v, --verbose', 'Verbose output')
  .action(action)
  .parse(process.argv)
